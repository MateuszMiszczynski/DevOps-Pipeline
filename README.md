# DevOps Project: Automated CI/CD & GitOps Pipeline

![Uploading image.png…]()


## Project Overview

This repository demonstrates a **fully automated DevOps pipeline** integrating **CI/CD** and **GitOps** practices. The project automatically deploys a simple **Python Flask web app** to a local **MiniKube** cluster on every GitHub push.

It showcases **modern DevOps skills**: infrastructure automation, containerization, CI/CD pipelines, and GitOps deployment.

---

## Architecture & Technologies

**Infrastructure as Code (IaC) – Terraform**
Manages the MiniKube cluster lifecycle and deploys **Argo CD** using Helm, enabling reproducible environments.

**Kubernetes Cluster – MiniKube (Docker driver)**
Runs a lightweight local Kubernetes cluster with essential add-ons for storage and provisioning.

**Application – Python (Flask)**
A simple web app that returns the current timestamp, containerized using Docker.

**Continuous Integration (CI) – GitHub Actions**
Builds the Docker image, tags it with the commit SHA, pushes it to Docker Hub, and updates the Helm chart `values.yaml` automatically.

**Package Management – Helm**
Simplifies deployment and configuration management by dynamically referencing image tags.

**Continuous Delivery / GitOps – Argo CD**
Monitors the GitHub repository, ensures the cluster state matches Git, and automates deployments.

---

## Workflow (How the Automation Works)

### 1. Code Change
A developer modifies the `app.py` file and runs `git push`. This triggers the entire pipeline.

### 2. Continuous Integration (CI) – GitHub Actions
The GitHub Actions pipeline automatically:

- builds the application's Docker image,
- tags it with the commit hash (e.g., `94cfc55`),
- pushes the image to Docker Hub,
- updates the image tag inside the `values.yaml` file (Helm Chart),
- commits this change back to the repository.

### 3. GitOps / Continuous Delivery (CD) – Argo CD
Argo CD continuously watches the Git repository.  
When it detects a tag update in `values.yaml`, it automatically:

- synchronizes the cluster,
- deploys the new version of the application,
- ensures that the cluster state matches the repository state (GitOps principle).

### 4. Deployment Verification
The developer performs port-forwarding and opens the application in the browser to view the new version.

## Setup

```bash
# Initialize Terraform
cd terraform-configs/
terraform init -upgrade

# Plan & Apply Infrastructure
terraform plan
terraform apply
# The first terraform apply may fail because Terraform must create the Docker container before configuring the rest. Running terraform apply a second time resolves the issue.

# Access Argo CD UI
kubectl port-forward svc/argocd-server -n argocd 8081:443
# Port forwarding may vary depending on your system.

# Open https://127.0.0.1:8081 in a browser
# Login credentials:
# Username: admin
# Password:
kubectl get secret argocd-initial-admin-secret -n argocd -o jsonpath="{.data.password}" | base64 -d
# And then use it in this command to login into Argo CD CLI
argocd login localhost:8081 --username admin --password <password> --insecure

# Connect Git Repository - Generate a GitHub Personal Access Token (PAT) with repo authorization first
argocd repo add <repo_url> --username <github_username> --password <personal_access_token> --server localhost:8081 --insecure

# Deploy Application via Argo CD
kubectl apply -f argocd-path.yaml

# Access the application
kubectl get pods --all-namespaces

# Find the pod running in the "default" NAMESPACE and than forward it
kubectl port-forward pod/<pod_name> 8080:8080 -n default

# Open the application http://localhost:8080


```

---

## Testing the Full GitOps (CI/CD) Loop

To test the entire pipeline:

1. **Make a change** in `app.py`.

2. **Commit and push the code:**
```bash
git add .
git commit -m "Update: new feature message"
git pull      # merge the automatic commit generated by GitHub Actions (values.yaml)
git push origin main


```

---

## Skills & Key Takeaways

This project provided hands-on experience in areas essential for a DevOps role:

- **IaC (Infrastructure as Code)**  
  Automated management of a local Kubernetes cluster (MiniKube) using Terraform.

- **GitOps (Argo CD)**  
  Self-healing deployments, tracking changes in Git, and full application state synchronization.

- **CI/CD with GitHub Actions**  
  Automating the build, tagging, publishing of Docker images, and updating Helm Charts.

- **Helm**  
  Simplified and repeatable application deployments on Kubernetes.

- **Containerization (Docker)**  
  Building, optimizing, and publishing container images.

- **DevOps Best Practices**  
  Integration of automation, version control, declarative infrastructure, and container orchestration.


---


## References

* [Terraform](https://www.terraform.io/docs)
* [MiniKube](https://minikube.sigs.k8s.io/docs/)
* [GitHub Actions](https://docs.github.com/en/actions)
* [Helm](https://helm.sh/docs/)
* [Argo CD]([https://argo-cd.readthedocs.io/](https://argo-cd.readthedocs.io/)
* This project is based on a tutorial from YouTube by "The DevOps Dude" , but I have fully implemented it myself, configured the pipeline, and experimented with customization in CI/CD and GitOps workflows.
